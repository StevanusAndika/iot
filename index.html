<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Face Recognition + ESP32 Camera</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--text:#e6eef6;--muted:#8fa4bf;--btn:#2b6cb0;--btn2:#334155;--border:#1b2b48;--success:#10b981;--error:#ef4444}
  *{box-sizing:border-box}
  body{margin:16px;background:var(--bg);color:var(--text);font:14px/1.55 system-ui,Segoe UI,Roboto,Arial}
  .card{max-width:1200px;margin:auto;background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:20px;box-shadow:0 10px 24px rgba(0,0,0,.5)}
  h2{margin:0 0 15px;color:var(--text)}
  .muted{color:var(--muted)}
  label{display:block;margin:.5rem 0 .2rem;color:#9fb0c9;font-size:13px}
  input,select{width:100%;padding:10px;border-radius:8px;border:1px solid #20314a;background:#071623;color:#dfeefc;font-size:14px}
  button{padding:10px 16px;border:0;border-radius:10px;background:var(--btn);color:#fff;cursor:pointer;font-size:14px;transition:all 0.2s}
  button:hover{opacity:0.9;transform:translateY(-1px)}
  button.secondary{background:var(--btn2)}
  button.success{background:var(--success)}
  button.error{background:var(--error)}
  button:disabled{opacity:.6;cursor:not-allowed;transform:none}
  .grid{display:grid;grid-template-columns:1fr 140px 140px 220px;gap:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:end}
  #canvas{width:100%;max-width:1000px;border-radius:10px;background:#000;display:block;border:2px solid var(--border)}
  #video{width:100%;max-width:1000px;border-radius:10px;margin:10px 0;display:none;opacity:.9;border:2px solid var(--border)}
  .pill{display:inline-block;padding:6px 12px;border-radius:999px;background:#1a2a44;margin-left:8px;font-size:12px}
  pre{white-space:pre-wrap;background:#071623;padding:12px;border-radius:8px;max-height:200px;overflow-y:auto;font-size:12px}
  .status-connected{color:var(--success);background:rgba(16,185,129,0.1);padding:8px 12px;border-radius:6px;font-size:13px}
  .status-disconnected{color:var(--error);background:rgba(239,68,68,0.1);padding:8px 12px;border-radius:6px;font-size:13px}
  .section{margin-bottom:20px;padding-bottom:20px;border-bottom:1px solid var(--border)}
  .cam-source{display:flex;align-items:center;gap:10px;margin:10px 0}
  .storage-controls{display:flex;gap:10px;margin-top:15px;padding:15px;background:rgba(59,130,246,0.1);border-radius:8px;flex-wrap:wrap}
  .storage-status{margin-top:10px;padding:10px;border-radius:8px;background:rgba(16,185,129,0.1);color:var(--success);font-size:13px}
</style>
</head>
<body>
  <div class="card">
    <h2>ğŸ­ Face Recognition â€” ESP32 Camera Integration <span class="pill">LBP + Cosine</span></h2>

    <div class="section">
      <div class="grid">
        <div>
          <label>ğŸ“· Pilih Sumber Kamera</label>
          <select id="cameraSource">
            <option value="webcam">Webcam Browser</option>
            <option value="esp32" selected>ESP32 Camera</option>
          </select>
        </div>
        <div>
          <label>ğŸ“ Ukuran Canvas</label>
          <select id="size">
            <option value="320x240">320Ã—240</option>
            <option value="480x360">480Ã—360</option>
            <option value="640x480" selected>640Ã—480</option>
          </select>
        </div>
        <div>
          <label>âš¡ Process every N frames</label>
          <select id="nth">
            <option value="1">N=1</option>
            <option value="2" selected>N=2</option>
            <option value="3">N=3</option>
            <option value="4">N=4</option>
          </select>
        </div>
        <div class="row">
          <button id="start" disabled>ğŸš€ Start</button>
          <button id="stop" class="secondary" disabled>ğŸ›‘ Stop</button>
          <label style="display:flex;gap:6px;align-items:center;color:#9fb0c9">
            <input type="checkbox" id="showVideo"> ğŸ‘€ Preview
          </label>
        </div>
      </div>

      <div id="esp32Config" style="margin-top:15px;padding:15px;background:rgba(59,130,246,0.1);border-radius:8px;">
        <div class="row">
          <div style="flex:1">
            <label>ğŸ”— URL ESP32 Camera</label>
            <input id="espUrl" placeholder="http://192.168.4.1" value="http://192.168.4.1">
          </div>
          <div style="min-width:120px">
            <label>ğŸ”‘ API Key</label>
            <input id="espKey" placeholder="rahasiaku123" value="rahasiaku123">
          </div>
          <div class="row">
            <button id="testConnection" class="success">ğŸ” Test Connection</button>
            <div id="connectionStatus" class="status-disconnected">âŒ Not Connected</div>
          </div>
        </div>
      </div>
    </div>

    <!-- TAMBAHAN: Local Storage Controls -->
    <div class="section">
      <h3>ğŸ’¾ Local Storage Management</h3>
      <p class="muted" style="margin-bottom:10px;">
        Kelola data wajah di local storage browser
      </p>
      
      <div class="storage-controls">
        <div style="flex:1">
          <label>ğŸ“ Nama untuk Simpan Manual</label>
          <input id="manualName" placeholder="Masukkan nama untuk simpan manual">
        </div>
        <div class="row" style="margin-top:20px;width:100%;">
          <button id="saveCurrentFace" class="success" disabled>ğŸ’¾ Simpan Wajah Sekarang</button>
          <button id="getLocalData" class="secondary">ğŸ“± Lihat Data Lokal</button>
          <button id="clearLocalData" class="error">ğŸ—‘ï¸ Hapus Semua Data Lokal</button>
          <button id="exportLocalData" class="secondary">ğŸ“¤ Export ke File</button>
          <label class="secondary" style="padding:10px 16px;border-radius:10px;cursor:pointer;display:inline-flex;align-items:center;gap:6px;background:#334155">
            ğŸ“¥ Import dari File<input id="importLocalData" type="file" accept="application/json" style="display:none">
          </label>
        </div>
      </div>
      
      <div id="localStorageStatus" style="display:none;margin-top:10px;padding:10px;border-radius:8px;background:rgba(59,130,246,0.1);color:var(--text);font-size:13px">
        Status local storage akan muncul di sini
      </div>
    </div>

    <!-- TAMBAHAN: Cloudflare Storage Controls -->
    <div class="section">
      <h3>â˜ï¸ Cloudflare D1 Database Storage</h3>
      <p class="muted" style="margin-bottom:10px;">
        Sync data antara local storage dan Cloudflare D1 Database
      </p>
      
      <div class="storage-controls">
        <div style="flex:1">
          <label>ğŸ”— Worker URL (Cloudflare)</label>
          <input id="cfWorkerUrl" placeholder="https://your-worker.your-subdomain.workers.dev" value="">
        </div>
        <div style="min-width:120px">
          <label>ğŸ”‘ API Token</label>
          <input id="cfApiToken" placeholder="your-api-token" value="" type="password">
        </div>
        <div class="row" style="margin-top:20px;width:100%;">
          <button id="getCloudData" class="success">â˜ï¸ Ambil Data dari Cloud</button>
          <button id="syncToCloud" class="success">ğŸ“¤ Sync ke Cloud</button>
          <button id="loadFromCloud" class="secondary">ğŸ“¥ Load dari Cloud ke Lokal</button>
          <button id="testCloudConnection" class="success">ğŸ” Test Koneksi</button>
        </div>
      </div>
      
      <div id="cloudStatus" style="display:none;" class="storage-status">
        Cloudflare connection status will appear here
      </div>
    </div>

    <div class="section">
      <div class="row">
        <div style="min-width:200px">
          <label>ğŸ‘¤ Nama untuk Enroll</label>
          <input id="name" placeholder="mis: Sismadi">
        </div>
        <div style="min-width:120px">
          <label>ğŸ“Š Sample Count</label>
          <select id="samples">
            <option>10</option>
            <option>15</option>
            <option selected>20</option>
            <option>30</option>
          </select>
        </div>
        <div style="min-width:150px">
          <label>ğŸšï¸ Threshold Cosine</label>
          <input id="th" value="0.90" type="number" step="0.01" min="0.5" max="1.0">
        </div>
        <div class="row">
          <button id="enroll" class="secondary" disabled>ğŸ“¸ Enroll Face (Otomatis)</button>
          <button id="exportDb" class="secondary">ğŸ“¤ Export JSON</button>
          <div id="dbStatus" style="padding:10px 16px;border-radius:10px;background:rgba(59,130,246,0.1);color:var(--text);font-size:14px">
            Data: 0 wajah
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="row">
        <div style="min-width:180px">
          <label>â±ï¸ Auto-OFF (detik)</label>
          <input id="espOff" value="5" type="number" min="1" max="60">
        </div>
        <div class="row">
          <button id="testOn" class="success">ğŸ’¡ Test LED ON</button>
          <button id="testOff" class="secondary">ğŸ”Œ Test LED OFF</button>
          <label style="display:flex;gap:6px;align-items:center;color:#9fb0c9">
            <input type="checkbox" id="autoTrigger" checked> ğŸ¤– Auto LED saat Verified
          </label>
        </div>
      </div>
    </div>

    <p class="muted" id="status">â³ Status: memuat OpenCV (WASM)â€¦</p>
    
    <div class="cam-source">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <p class="muted" style="margin-top:12px">
      ğŸ’¡ <strong>Tips:</strong> Enroll wajah di pencahayaan baik dengan beberapa pose. 
      Pastikan ESP32 dan komputer dalam jaringan WiFi yang sama (ESP32-Camera-AP).
    </p>
    
    <pre id="log" class="muted">Log akan muncul di sini...</pre>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  
  <script>
  // ===== DOM References =====
  const $ = (id) => document.getElementById(id);
  const camSourceEl = $("cameraSource"), nthEl = $("nth"), sizeEl = $("size"), 
        btnS = $("start"), btnT = $("stop"), showVideoCb = $("showVideo");
  const nameEl = $("name"), samplesEl = $("samples"), thEl = $("th"), 
        btnEnroll = $("enroll"), btnExport = $("exportDb"), dbStatusEl = $("dbStatus");
  const espUrlEl = $("espUrl"), espKeyEl = $("espKey"), espOffEl = $("espOff"), 
        btnTestOn = $("testOn"), btnTestOff = $("testOff"), autoTriggerEl = $("autoTrigger"),
        testConnBtn = $("testConnection"), connStatusEl = $("connectionStatus");
  
  // Local Storage elements
  const manualNameEl = $("manualName"), btnSaveCurrent = $("saveCurrentFace"),
        btnGetLocal = $("getLocalData"), btnClearLocal = $("clearLocalData"),
        btnExportLocal = $("exportLocalData"), importLocalEl = $("importLocalData"),
        localStorageStatusEl = $("localStorageStatus");
  
  // Cloudflare elements
  const cfWorkerUrlEl = $("cfWorkerUrl"), cfApiTokenEl = $("cfApiToken"),
        btnGetCloud = $("getCloudData"), btnSyncToCloud = $("syncToCloud"),
        btnLoadFromCloud = $("loadFromCloud"), btnTestCloud = $("testCloudConnection"),
        cloudStatusEl = $("cloudStatus");
  
  const statusEl = $("status"), logEl = $("log"), video = $("video"), 
        canvas = $("canvas"), ctx = canvas.getContext('2d');

  // ===== System Variables =====
  let stream = null, running = false, rafId = null, enrolling = false, 
      enrollLeft = 0, enrollSum = null;
  let detectEveryN = 2, frameIndex = 0, facesCount = 0, procFPS = 0, 
      lastFPS = 0, procCount = 0;
  let classifier = null, gray = null, rgba = null;
  let usingESP32Camera = true;
  let currentFaceDescriptor = null; // Untuk simpan wajah saat ini
  
  const cascadeURL = 'https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_alt2.xml';
  const DB_KEY = 'face_db_v2';
  const LBP_SIZE = 100;

  // ===== Utility Functions =====
  function log(...args) { 
    console.log(...args); 
    const timestamp = new Date().toLocaleTimeString();
    logEl.textContent = `[${timestamp}] ${args.join(" ")}\n` + logEl.textContent.slice(0, 2000); 
  }

  function showLocalStatus(message, type = 'info') {
    localStorageStatusEl.style.display = 'block';
    localStorageStatusEl.textContent = message;
    
    if (type === 'success') {
      localStorageStatusEl.style.backgroundColor = 'rgba(16,185,129,0.1)';
      localStorageStatusEl.style.color = 'var(--success)';
    } else if (type === 'error') {
      localStorageStatusEl.style.backgroundColor = 'rgba(239,68,68,0.1)';
      localStorageStatusEl.style.color = 'var(--error)';
    } else {
      localStorageStatusEl.style.backgroundColor = 'rgba(59,130,246,0.1)';
      localStorageStatusEl.style.color = 'var(--text)';
    }
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      localStorageStatusEl.style.display = 'none';
    }, 5000);
  }

  function showCloudStatus(message, type = 'info') {
    cloudStatusEl.style.display = 'block';
    cloudStatusEl.textContent = message;
    
    if (type === 'success') {
      cloudStatusEl.style.backgroundColor = 'rgba(16,185,129,0.1)';
      cloudStatusEl.style.color = 'var(--success)';
    } else if (type === 'error') {
      cloudStatusEl.style.backgroundColor = 'rgba(239,68,68,0.1)';
      cloudStatusEl.style.color = 'var(--error)';
    } else {
      cloudStatusEl.style.backgroundColor = 'rgba(59,130,246,0.1)';
      cloudStatusEl.style.color = 'var(--text)';
    }
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      cloudStatusEl.style.display = 'none';
    }, 5000);
  }

  function loadDB() { 
    try { 
      const db = JSON.parse(localStorage.getItem(DB_KEY) || '{"labels":[]}');
      updateDBStatus(db.labels.length);
      return db;
    } catch(e) { 
      log("Error loading DB:", e);
      return {labels:[]}; 
    } 
  }

  function saveDB(db) { 
    localStorage.setItem(DB_KEY, JSON.stringify(db)); 
    updateDBStatus(db.labels.length);
    log("Database saved locally:", db.labels.length, "faces");
  }

  function updateDBStatus(count) {
    dbStatusEl.textContent = `Data: ${count} wajah`;
  }

  function clearLocalDB() { 
    localStorage.removeItem(DB_KEY); 
    updateDBStatus(0);
    log("Local database cleared");
    showLocalStatus('âœ… Semua data lokal telah dihapus', 'success');
  }

  function bestMatch(vec, db) { 
    if (!db.labels.length) return {name: "Unknown", score: 0}; 
    let best = {name: "Unknown", score: 0}; 
    for (const r of db.labels) { 
      const s = cosine(vec, r.vec); 
      if (s > best.score) best = {name: r.name, score: s}; 
    } 
    return best; 
  }

  function lbpHistFromBytes(bytes, w, h) {
    const hist = new Float32Array(256);
    for (let y = 1; y < h-1; y++) {
      const yp = y * w;
      for (let x = 1; x < w-1; x++) {
        const c = bytes[yp + x];
        const code = (
          (bytes[(y-1)*w + (x-1)] >= c) << 7 |
          (bytes[(y-1)*w + (x  )] >= c) << 6 |
          (bytes[(y-1)*w + (x+1)] >= c) << 5 |
          (bytes[(y  )*w + (x+1)] >= c) << 4 |
          (bytes[(y+1)*w + (x+1)] >= c) << 3 |
          (bytes[(y+1)*w + (x  )] >= c) << 2 |
          (bytes[(y+1)*w + (x-1)] >= c) << 1 |
          (bytes[(y  )*w + (x-1)] >= c) << 0
        );
        hist[code] += 1;
      }
    }
    let norm = 0;
    for (let i = 0; i < 256; i++) norm += hist[i] * hist[i];
    norm = Math.sqrt(norm) || 1;
    for (let i = 0; i < 256; i++) hist[i] /= norm;
    return hist;
  }

  function addInPlace(a, b) { for (let i = 0; i < a.length; i++) a[i] += b[i]; }
  function scaleInPlace(a, s) { for (let i = 0; i < a.length; i++) a[i] *= s; }
  function cosine(a, b) { 
    let dot = 0, na = 0, nb = 0; 
    for (let i = 0; i < a.length; i++) { 
      dot += a[i] * b[i]; 
      na += a[i] * a[i]; 
      nb += b[i] * b[i]; 
    } 
    return dot / (Math.sqrt(na) * Math.sqrt(nb) + 1e-9); 
  }

  // ===== LOCAL STORAGE FUNCTIONS =====
  function getLocalData() {
    const db = loadDB();
    const count = db.labels.length;
    
    log("ğŸ“± Local database loaded:", count, "faces");
    showLocalStatus(`ğŸ“± Data lokal: ${count} wajah tersimpan`, 'info');
    
    // Show preview of data
    const preview = db.labels.slice(0, 3).map(l => l.name).join(', ');
    if (count > 0) {
      log("ğŸ“‹ Nama-nama:", preview + (count > 3 ? '...' : ''));
      log("ğŸ“Š Detail:", db.labels.map(l => `${l.name} (vector: ${l.vec.length})`));
    }
    
    return db;
  }

  function saveCurrentFaceToLocal() {
    if (!currentFaceDescriptor) {
      showLocalStatus('âŒ Tidak ada wajah yang terdeteksi', 'error');
      log("âŒ Tidak ada wajah yang terdeteksi untuk disimpan");
      return false;
    }

    const name = manualNameEl.value.trim();
    if (!name) {
      showLocalStatus('âŒ Masukkan nama terlebih dahulu', 'error');
      log("âŒ Nama belum diisi");
      manualNameEl.focus();
      return false;
    }

    const db = loadDB();
    
    // Remove existing entries with same name
    db.labels = db.labels.filter(entry => entry.name !== name);
    
    // Add new entry
    db.labels.push({
      name: name,
      vec: Array.from(currentFaceDescriptor)
    });
    
    saveDB(db);
    
    showLocalStatus(`âœ… Wajah "${name}" berhasil disimpan ke local storage`, 'success');
    log(`âœ… Face saved locally: ${name}`);
    
    // Clear input
    manualNameEl.value = '';
    
    return true;
  }

  function exportLocalDataToFile() {
    const db = loadDB();
    
    if (db.labels.length === 0) {
      showLocalStatus('âš ï¸ Tidak ada data lokal untuk diexport', 'info');
      return;
    }
    
    const blob = new Blob([JSON.stringify(db, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `face_db_local_${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    log("ğŸ’¾ Local database exported");
    showLocalStatus(`âœ… ${db.labels.length} wajah diexport ke file`, 'success');
  }

  async function importLocalDataFromFile(e) {
    const file = e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const db = JSON.parse(text);
      
      if (!db || !Array.isArray(db.labels)) {
        throw new Error('Format file tidak valid');
      }

      saveDB(db);
      showLocalStatus(`âœ… Database imported: ${db.labels.length} wajah dimuat`, 'success');
      log(`ğŸ“¥ Database imported: ${db.labels.length} faces`);
      
      // Reset file input
      e.target.value = '';
    } catch (error) {
      showLocalStatus(`âŒ Error importing: ${error.message}`, 'error');
      log("âŒ Import error:", error);
    }
  }

  // ===== CLOUDFLARE FUNCTIONS =====
  function getWorkerUrl() {
    let workerUrl = cfWorkerUrlEl.value.trim();
    workerUrl = workerUrl.replace(/\/$/, '');
    return workerUrl;
  }

  async function testCloudConnection() {
    const workerUrl = getWorkerUrl();
    if (!workerUrl) {
      showCloudStatus('âŒ Worker URL belum diisi', 'error');
      return false;
    }
    
    btnTestCloud.disabled = true;
    btnTestCloud.textContent = "ğŸ” Testing...";
    
    try {
      const response = await fetch(`${workerUrl}/health`);
      
      if (response.ok) {
        const data = await response.json();
        showCloudStatus(`âœ… Cloudflare Worker terhubung: ${data.message || 'OK'}`, 'success');
        log("âœ… Cloudflare connection successful");
        return true;
      } else {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }
    } catch (error) {
      showCloudStatus(`âŒ Gagal terhubung: ${error.message}`, 'error');
      log("âŒ Cloudflare connection failed:", error);
      return false;
    } finally {
      btnTestCloud.disabled = false;
      btnTestCloud.textContent = "ğŸ” Test Koneksi";
    }
  }

  async function getCloudData() {
    const workerUrl = getWorkerUrl();
    if (!workerUrl) {
      showCloudStatus('âŒ Worker URL belum diisi', 'error');
      return;
    }
    
    btnGetCloud.disabled = true;
    btnGetCloud.textContent = "â˜ï¸ Loading...";
    
    try {
      const response = await fetch(`${workerUrl}/data`);
      
      if (response.ok) {
        const data = await response.json();
        log("â˜ï¸ Cloud database loaded:", data.length || 0, "faces");
        showCloudStatus(`â˜ï¸ Cloud data: ${data.length || 0} wajah tersimpan`, 'success');
        
        if (data.length > 0) {
          const preview = data.slice(0, 3).map(item => item.name).join(', ');
          log("ğŸ“‹ Cloud names:", preview + (data.length > 3 ? '...' : ''));
        }
        
        return data;
      } else {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }
    } catch (error) {
      showCloudStatus(`âŒ Gagal mengambil data: ${error.message}`, 'error');
      log("âŒ Failed to get cloud data:", error);
      return null;
    } finally {
      btnGetCloud.disabled = false;
      btnGetCloud.textContent = "â˜ï¸ Ambil Data dari Cloud";
    }
  }

  async function syncToCloud() {
    const workerUrl = getWorkerUrl();
    if (!workerUrl) {
      showCloudStatus('âŒ Worker URL belum diisi', 'error');
      return;
    }
    
    const localDB = loadDB();
    
    if (localDB.labels.length === 0) {
      showCloudStatus('âš ï¸ Tidak ada data lokal untuk dikirim ke cloud', 'info');
      return;
    }
    
    btnSyncToCloud.disabled = true;
    btnSyncToCloud.textContent = "ğŸ“¤ Syncing...";
    
    try {
      // Clear existing data in cloud
      await fetch(`${workerUrl}/data/clear`, { method: 'DELETE' });
      
      // Upload all local data
      for (const label of localDB.labels) {
        await fetch(`${workerUrl}/data`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(label)
        });
      }
      
      showCloudStatus(`âœ… ${localDB.labels.length} wajah berhasil disinkronisasi ke cloud!`, 'success');
      log(`âœ… Data synced to cloud: ${localDB.labels.length} faces`);
      
    } catch (error) {
      showCloudStatus(`âŒ Gagal sinkronisasi: ${error.message}`, 'error');
      log("âŒ Failed to sync to cloud:", error);
    } finally {
      btnSyncToCloud.disabled = false;
      btnSyncToCloud.textContent = "ğŸ“¤ Sync ke Cloud";
    }
  }

  async function loadFromCloud() {
    const cloudData = await getCloudData();
    
    if (!cloudData || cloudData.length === 0) {
      showCloudStatus('âš ï¸ Tidak ada data di cloud', 'info');
      return;
    }
    
    // Convert cloud data to local format
    const localDB = {
      labels: cloudData.map(item => ({
        name: item.name,
        vec: item.vector || item.vec || []
      }))
    };
    
    // Save to local storage
    saveDB(localDB);
    showCloudStatus(`âœ… ${localDB.labels.length} wajah berhasil dimuat dari cloud ke lokal!`, 'success');
    log(`âœ… Data loaded from cloud: ${localDB.labels.length} faces`);
  }

  // ===== OpenCV Initialization =====
  function onOpenCvReady() { 
    if (window.cv && cv.getBuildInformation) initOpenCV(); 
    else if (window.cv) cv['onRuntimeInitialized'] = initOpenCV; 
  }

  async function initOpenCV() {
    try {
      statusEl.textContent = 'â³ Status: memuat cascade classifierâ€¦';
      const res = await fetch(cascadeURL);
      if (!res.ok) throw new Error('Failed to load cascade');
      
      const buf = new Uint8Array(await res.arrayBuffer());
      cv.FS_createDataFile('/', 'haarcascade.xml', buf, true, false, false);
      
      classifier = new cv.CascadeClassifier();
      classifier.load('haarcascade.xml');
      
      statusEl.textContent = 'âœ… Status: OpenCV siap. Klik Start untuk mulai.';
      btnS.disabled = false;
      btnEnroll.disabled = false;
      btnSaveCurrent.disabled = false;
      
      // Load initial DB status
      loadDB();
      
      // Test ESP32 connection on startup
      setTimeout(testESP32Connection, 1000);
      
    } catch(e) {
      log("âŒ Error loading OpenCV:", e);
      statusEl.textContent = 'âŒ Status: gagal memuat cascade classifier.';
    }
  }

  // ===== ESP32 Camera Functions =====
  async function testESP32Connection() {
    const baseUrl = espUrlEl.value.trim();
    if (!baseUrl) return false;

    testConnBtn.disabled = true;
    testConnBtn.textContent = "ğŸ” Testing...";
    
    try {
      const response = await fetch(`${baseUrl}/status`, {
        method: 'GET',
        timeout: 5000
      });
      
      if (response.ok) {
        const data = await response.json();
        connStatusEl.className = "status-connected";
        connStatusEl.innerHTML = `âœ… Connected - ${data.clients} client(s)`;
        log("âœ… ESP32 connection successful");
        return true;
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      connStatusEl.className = "status-disconnected";
      connStatusEl.innerHTML = "âŒ Connection Failed";
      log("âŒ ESP32 connection failed:", error);
      return false;
    } finally {
      testConnBtn.disabled = false;
      testConnBtn.textContent = "ğŸ” Test Connection";
    }
  }

  async function setupESP32Camera() {
    const baseUrl = espUrlEl.value.trim();
    if (!baseUrl) {
      throw new Error("ESP32 URL belum diisi");
    }

    // Test connection first
    const connected = await testESP32Connection();
    if (!connected) {
      throw new Error("Tidak dapat terhubung ke ESP32");
    }

    // Setup video element for ESP32 stream
    video.src = `${baseUrl}/video`;
    video.crossOrigin = "anonymous";
    
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error("Timeout loading ESP32 video stream"));
      }, 10000);

      video.onloadeddata = () => {
        clearTimeout(timeout);
        log("âœ… ESP32 video stream loaded");
        resolve(true);
      };

      video.onerror = (err) => {
        clearTimeout(timeout);
        reject(new Error("Error loading ESP32 video stream"));
      };

      video.play().catch(reject);
    });
  }

  async function setupWebcam() {
    const { w, h } = parseSize(sizeEl.value);
    const constraints = {
      video: {
        width: { ideal: w },
        height: { ideal: h },
        facingMode: "user"
      },
      audio: false
    };

    try {
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
      log("âœ… Webcam started successfully");
      return true;
    } catch (error) {
      log("âŒ Webcam error:", error);
      throw error;
    }
  }

  // ===== Camera Control =====
  function parseSize(v) { 
    const [w, h] = v.split('x').map(n => parseInt(n, 10)); 
    return { w, h }; 
  }

  function setCanvasSize(v) { 
    const { w, h } = parseSize(v); 
    canvas.width = w; 
    canvas.height = h; 
  }

  async function startCamera() {
    usingESP32Camera = camSourceEl.value === "esp32";
    detectEveryN = parseInt(nthEl.value, 10) || 2;
    setCanvasSize(sizeEl.value);

    try {
      if (usingESP32Camera) {
        await setupESP32Camera();
        statusEl.textContent = 'âœ… Status: ESP32 camera aktif';
      } else {
        await setupWebcam();
        statusEl.textContent = 'âœ… Status: Webcam aktif';
      }

      running = true;
      btnS.disabled = true;
      btnT.disabled = false;
      video.style.display = showVideoCb.checked ? 'block' : 'none';
      startLoop();

    } catch (error) {
      log("âŒ Failed to start camera:", error);
      statusEl.textContent = `âŒ Error: ${error.message}`;
      
      // Fallback to webcam if ESP32 fails
      if (usingESP32Camera) {
        log("ğŸ”„ Falling back to webcam...");
        camSourceEl.value = "webcam";
        usingESP32Camera = false;
        await startCamera();
      }
    }
  }

  function stopCamera() {
    running = false;
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
    
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      stream = null;
    }
    
    video.srcObject = null;
    video.src = "";
    
    btnS.disabled = false;
    btnT.disabled = true;
    statusEl.textContent = 'â¸ï¸ Status: Stopped';
    
    // Clean up OpenCV mats
    if (rgba) { rgba.delete(); rgba = null; }
    if (gray) { gray.delete(); gray = null; }
  }

  // ===== ESP32 LED Control =====
  async function callLED(state) {
    const baseUrl = (espUrlEl.value || '').replace(/\/+$/, '');
    if (!baseUrl) {
      log("âŒ ESP32 URL belum diisi");
      return;
    }

    const apiKey = espKeyEl.value || 'rahasiaku123';
    
    try {
      const response = await fetch(`${baseUrl}/api/led`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': apiKey
        },
        body: JSON.stringify({ state: state })
      });

      const result = await response.json();
      log(`ğŸ’¡ LED ${state}:`, result.message);
      return result;
    } catch (error) {
      log("âŒ LED control error:", error);
      return { status: "error", message: error.message };
    }
  }

  let lastTrigger = 0;
  async function triggerOnVerified() {
    const enable = autoTriggerEl.checked;
    if (!enable) return;

    const now = Date.now();
    if (now - lastTrigger < 2000) return; // 2 second cooldown
    
    lastTrigger = now;
    
    const result = await callLED('on');
    if (result.status === "success") {
      const offSeconds = Math.max(1, parseInt(espOffEl.value || '5', 10));
      setTimeout(() => callLED('off'), offSeconds * 1000);
    }
  }

  // ===== UI Event Handlers =====
  btnS.onclick = startCamera;
  btnT.onclick = stopCamera;

  showVideoCb.onchange = () => {
    video.style.display = showVideoCb.checked ? 'block' : 'none';
  };

  btnEnroll.onclick = () => {
    const name = (nameEl.value || '').trim();
    if (!name) {
      alert('âš ï¸ Masukkan nama untuk enrollment otomatis');
      return;
    }
    
    enrolling = true;
    enrollLeft = parseInt(samplesEl.value, 10) || 20;
    enrollSum = new Float32Array(256);
    statusEl.textContent = `ğŸ“¸ Enrolling "${name}" â€” ${enrollLeft} samples remainingâ€¦`;
    log(`ğŸ¯ Starting enrollment for: ${name}`);
  };

  btnExport.onclick = exportLocalDataToFile;

  // Local Storage Event Handlers
  btnSaveCurrent.onclick = saveCurrentFaceToLocal;
  btnGetLocal.onclick = getLocalData;
  btnClearLocal.onclick = () => {
    if (confirm('ğŸ—‘ï¸ Apakah Anda yakin ingin menghapus semua data lokal?')) {
      clearLocalDB();
    }
  };
  btnExportLocal.onclick = exportLocalDataToFile;
  importLocalEl.onchange = importLocalDataFromFile;

  // Cloudflare Event Handlers
  btnGetCloud.onclick = getCloudData;
  btnSyncToCloud.onclick = syncToCloud;
  btnLoadFromCloud.onclick = loadFromCloud;
  btnTestCloud.onclick = testCloudConnection;

  btnTestOn.onclick = () => callLED('on');
  btnTestOff.onclick = () => callLED('off');
  testConnBtn.onclick = testESP32Connection;

  camSourceEl.onchange = () => {
    if (running) {
      stopCamera();
      setTimeout(startCamera, 500);
    }
  };

  // ===== Main Processing Loop =====
  function startLoop() {
    // Initialize OpenCV mats
    rgba && rgba.delete();
    gray && rgba.delete();
    
    rgba = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
    gray = new cv.Mat();
    
    const faces = new cv.RectVector();
    procFPS = 0;
    lastFPS = performance.now();
    procCount = 0;
    frameIndex = 0;

    const processFrame = () => {
      if (!running) {
        // Cleanup
        rgba.delete();
        gray.delete();
        faces.delete();
        return;
      }

      try {
        // Draw video to canvas
        if (video.readyState >= 2 && video.videoWidth > 0) {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          frameIndex++;

          // Process every Nth frame
          if (frameIndex % detectEveryN === 0) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            rgba.data.set(imageData.data);
            
            // Convert to grayscale
            cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);
            cv.equalizeHist(gray, gray);
            
            // Detect faces
            classifier.detectMultiScale(gray, faces, 1.1, 5, 0, new cv.Size(60, 60));
            facesCount = faces.size();

            let displayText = '';
            
            if (faces.size() > 0) {
              // Find largest face
              let bestIndex = 0, bestArea = 0;
              for (let i = 0; i < faces.size(); i++) {
                const rect = faces.get(i);
                const area = rect.width * rect.height;
                if (area > bestArea) {
                  bestArea = area;
                  bestIndex = i;
                }
              }

              const faceRect = faces.get(bestIndex);
              
              // Extract and resize face region
              let roi = gray.roi(faceRect);
              let resized = new cv.Mat();
              cv.resize(roi, resized, new cv.Size(LBP_SIZE, LBP_SIZE), 0, 0, cv.INTER_AREA);
              
              // Compute LBP descriptor
              const descriptor = lbpHistFromBytes(resized.data, resized.cols, resized.rows);
              
              // Simpan descriptor untuk tombol "Simpan Wajah Sekarang"
              currentFaceDescriptor = descriptor;

              if (enrolling) {
                // Enrollment mode
                addInPlace(enrollSum, descriptor);
                enrollLeft--;
                
                statusEl.textContent = `ğŸ“¸ Enrolling "${nameEl.value.trim()}" â€” ${enrollLeft} samples left`;
                
                if (enrollLeft <= 0) {
                  // Finish enrollment
                  scaleInPlace(enrollSum, 1 / parseInt(samplesEl.value, 10));
                  
                  const db = loadDB();
                  // Remove existing entries with same name
                  db.labels = db.labels.filter(entry => entry.name !== nameEl.value.trim());
                  // Add new entry
                  db.labels.push({
                    name: nameEl.value.trim(),
                    vec: Array.from(enrollSum)
                  });
                  
                  saveDB(db);
                  enrolling = false;
                  
                  statusEl.textContent = `âœ… Enrollment completed for "${nameEl.value.trim()}"`;
                  log(`âœ… Enrollment completed: ${nameEl.value.trim()}`);
                  showLocalStatus(`âœ… Enrollment otomatis selesai: ${nameEl.value.trim()}`, 'success');
                }
              } else {
                // Recognition mode
                const db = loadDB();
                const match = bestMatch(descriptor, db);
                const threshold = parseFloat(thEl.value) || 0.9;
                
                if (match.score >= threshold) {
                  displayText = `${match.name} (${match.score.toFixed(2)})`;
                  triggerOnVerified();
                } else {
                  displayText = `Unknown (${match.score.toFixed(2)})`;
                }
              }

              // Draw face rectangles
              ctx.lineWidth = Math.max(2, Math.round(canvas.width / 200));
              
              for (let i = 0; i < faces.size(); i++) {
                const rect = faces.get(i);
                ctx.strokeStyle = i === bestIndex ? '#00ff66' : '#66a3ff';
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
              }

              // Draw recognition text
              if (displayText) {
                const rect = faces.get(bestIndex);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const textWidth = ctx.measureText(displayText).width + 14;
                ctx.fillRect(rect.x, rect.y - 24, textWidth, 20);
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px system-ui, Segoe UI, Roboto, Arial';
                ctx.fillText(displayText, rect.x + 7, rect.y - 8);
              }

              // Cleanup
              roi.delete();
              resized.delete();
            } else {
              currentFaceDescriptor = null; // Reset jika tidak ada wajah
            }

            // Update FPS counter
            procCount++;
            const now = performance.now();
            if (now - lastFPS > 1000) {
              procFPS = procCount / ((now - lastFPS) / 1000);
              procCount = 0;
              lastFPS = now;
            }
          }
        }
      } catch (error) {
        log("âŒ Processing error:", error);
      }

      drawHUD();
      scheduleNextFrame();
    };

    const scheduleNextFrame = () => {
      if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
        video.requestVideoFrameCallback(processFrame);
      } else {
        rafId = requestAnimationFrame(processFrame);
      }
    };

    scheduleNextFrame();
  }

  function drawHUD() {
    const padding = 10, lineHeight = 18;
    const fpsText = `FPS: ${Math.round(procFPS)}`;
    const facesText = `Faces: ${facesCount}`;
    const enrollText = enrolling ? `Enrolling: ${nameEl.value.trim()} (${enrollLeft} left)` : '';
    const saveText = currentFaceDescriptor ? 'ğŸ’¾ Siap simpan' : 'â³ Tunggu wajah';
    
    ctx.save();
    ctx.font = '14px system-ui, Segoe UI, Roboto, Arial';
    
    const texts = [fpsText, facesText, saveText];
    if (enrolling) texts.push(enrollText);
    
    const maxWidth = Math.max(...texts.map(t => ctx.measureText(t).width)) + padding * 2;
    const totalHeight = texts.length * lineHeight + padding * 2;
    
    // Background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(padding, padding, maxWidth, totalHeight);
    
    // Text
    ctx.fillStyle = '#e6eef6';
    texts.forEach((text, index) => {
      ctx.fillText(text, padding * 2, padding + (index + 1) * lineHeight);
    });
    
    ctx.restore();
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', () => {
    log("ğŸš€ Face Recognition System Initialized");
    log("ğŸ’¡ Connect to ESP32-Camera-AP WiFi to use ESP32 camera");
    log("ğŸ’¾ Local storage ready - gunakan tombol 'Simpan Wajah Sekarang'");
    
    // Auto-fill Cloudflare settings
    cfWorkerUrlEl.value = 'https://iot.stevanusstudent.workers.dev';
    
    // Load initial DB status
    getLocalData();
    
    // Save Cloudflare settings on change
    cfWorkerUrlEl.addEventListener('change', () => {
      localStorage.setItem('cf_worker_url', cfWorkerUrlEl.value);
    });
    
    cfApiTokenEl.addEventListener('change', () => {
      localStorage.setItem('cf_api_token', cfApiTokenEl.value);
    });
  });
  </script>
</body>
</html>